<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wuli观观</title>
  
  <subtitle>嘻嘻嘻 @_@</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.fuguiguan.cn/"/>
  <updated>2018-11-14T01:58:10.729Z</updated>
  <id>http://www.fuguiguan.cn/</id>
  
  <author>
    <name>Fu GuiG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序算法总结</title>
    <link href="http://www.fuguiguan.cn/2018/09/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://www.fuguiguan.cn/2018/09/23/排序算法总结/</id>
    <published>2018-09-23T08:17:23.794Z</published>
    <updated>2018-11-14T01:58:10.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用排序算法总结"><a href="#常用排序算法总结" class="headerlink" title="常用排序算法总结"></a>常用排序算法总结</h1><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li><p>一般方法 ：</p><blockquote><p>在第P趟，将位置P上的元素向左移动到它在前P+1个元素中的正确位置上。对于P=1到P=N-1趟，插入排序保证从位置0到位置P上的元素为已排序状态。</p></blockquote></li><li><p>复杂度  </p><blockquote><p>最好的情况：数组完全有序，每次插入只需要和插入位置的前一个元素，因此复杂度为O(N);<br>最坏的情况：数组完全逆序，在插入第n个位置时，需要比较前n-1 个，次数为1+2+···+n-1+n=n*(n-1)/2. 因此复杂度为O(n^2).</p></blockquote></li></ul><hr><p><strong>JavaScript算法实现</strong></p><pre><code>function InsertionSort(arr,n) {var j,p,temp;//p趟插入,n=arr.length时能完全排序for (p = 1; p &lt; n; p++) {    temp = arr[p];    for(j=p; j&gt;0&amp;&amp;arr[j-1]&gt;temp; j--) {        arr[j] = arr[j-1];    }    arr[j] = temp;}return arr;}</code></pre><hr><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul><li><p>算法步骤</p><blockquote><ol><li>如果数组S的元素个数是1或0，则返回。<ol start="2"><li>取S中任一元素v，作为枢纽 元。</li><li>将S-{v} 分为两个不相交的集合：S1={x∊S-{v} | x&lt;=v} 和 S2={x∊S-{v} | x&gt;=v} </li><li>返回 { quicksort(s1)后，继而v,进而 quicksort(s2) }</li></ol></li></ol></blockquote></li><li><p>算法分析</p><blockquote><p>它的平均运行时间为O(N log N),它的最坏性能为O(N^2).</p></blockquote></li><li><p>算法思想以及算法实现</p></li></ul><ol><li><p>选取枢纽元</p><blockquote><p>三中值法：一般方法是选择左端、右端和中心位置上的三个元素中值作为枢纽元</p></blockquote><pre><code>var media3 = arr[0].concat(pivot,arr.pop()).sort((a,b)=&gt;{return a-b;})[1];</code></pre><blockquote><p>后面用递归法实现s1 . s2 的排序</p></blockquote><p>   function quickSort(arr) {</p><pre><code>if(arr.length&lt;=1){  return arr;}var pivotIndex = parseInt(arr.length/2);var pivot = arr[pivotIndex];//直接选取中间值为枢纽元var left = [];var right = [];for(var i=0;i&lt;arr.length;i++) {  if(arr[i]&lt;pivot){    left.push(arr[i]);  }  else{    right.push(arr[i]);  }}return quickSort(left).concat(pivot,quickSort(right));</code></pre><p>  }</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用排序算法总结&quot;&gt;&lt;a href=&quot;#常用排序算法总结&quot; class=&quot;headerlink&quot; title=&quot;常用排序算法总结&quot;&gt;&lt;/a&gt;常用排序算法总结&lt;/h1&gt;&lt;h3 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
  </entry>
  
</feed>
